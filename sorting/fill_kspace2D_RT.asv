function [kspace,averages,nr_dynamics]=fill_kspace2D_RT(raw,includewindow,nr_of_card_frames,nr_of_resp_frames,number_of_shared_frames,dimz,dimy,nr_ksteps,dimx,bin_times_card,card_bin_ass,resp_bin_ass,trajectory)

% This function creates 3 arrays
% (1) the kspace data sorted into the correct cardiac frames,  and phase-encoding positions
% (2) an array with the same size that keeps track of the number of averages per k-space point for normalization/statistics purposes
% (3) the number of dynamics = number of heart-beats in the datasets

% Required input:
%
% raw                   = unsorted k-space data
% navheart              = navigator signal, used to construct an average heartbeat
% nr_of_card_frames     = number of desired cardiac frames, must be consisted with bin assignments (bin_ass)
% nr_of_resp_frames     = number of desired respiratory frames
% nr_of_dynamics        = number of desired dynamics
% dimz                  = number of slices
% dimy                  = dimensions of the images: dimy (phase encoding)
% nr_ksteps             = number of k-lines in 1 repetition
% dimx                  = dimensions of the images: dimx (readout)
% card_bin_ass          = the cardiac bin assignment array for all measured k-lines
% resp_bin_ass          = the respiratory bin assignment array for all measured k-lines
% traj                  = the k-space trajectory
% includewindow         = data which should be include: 1 = yes, 0 = no

clc;

nr_dynamics = round(length(bin_times_card)/nr_of_card_frames);                              % number of dynamics equals the number of heartbeats in the acquisition
kspace = complex(zeros(nr_of_resp_frames,nr_of_card_frames,dimz,dimy,dimx,nr_dynamics));    % fill temp k-space with zeros
averages = zeros(nr_of_resp_frames,nr_of_card_frames,dimz,dimy,dimx,nr_dynamics);           % fill temp nr averages array with zeros
nr_reps = size(raw,1);                                                                      % number of k-space repetitions
totalk = nr_reps * nr_ksteps * dimz;                                                        % total number of k-lines

% unsorted k-lines
unsorted_klines = reshape(raw,[totalk,dimx]);

% sharing k-lines from neighboring dynamics
sh = [1:number_of_shared_frames]-round(number_of_shared_frames/2);


% fill k-space
fcnt = 1;
 
for i = 1 : nr_dynamics
    
    for j = 1 : nr_of_card_frames
     
        for kcnt = 1:totalk
            
            if fcnt < length (bin_times_card)
                
                if kcnt > bin_times_card(1,fcnt) && kcnt < bin_times_card(1,fcnt+1)
                    
                    kline = trajectory(mod(kcnt - 1,nr_ksteps) + 1);        % the phase-encoding step using the trajectory info
                    
                    
                    for w = 1:number_of_shared_frames
                        
                        
                    
                        if 1 = 1
                        
                    kspace(1,j,1,kline,:,i) = kspace(1,j,1,kline,:,i) + unsorted_klines(kcnt,:);      % add the data to the correct k-position
                    averages(1,j,1,kline,:,i) = averages(1,j,1,kline,:,i) + 1;
                           
                        end
                    
                    end
                    
                end
                
            end
            
        end
        
        fcnt = fcnt + 1;
                
    end
    
end







kspace = kspace./averages;   % normalize by number of averages
kspace(isnan(kspace)) = complex(0); % correct for NaN or Inf because of division by zero in case of missing k-lines
kspace(isinf(kspace)) = complex(0);


% Apply a circular Tukey filter
filterwidth = 0.2;
flt = circtukey2D(dimy,dimx,filterwidth);
tukeyfilter(1,1,1,:,:,1) = flt;
kspace = kspace.*tukeyfilter;


disp(size(kspace))

disp(nnz(kspace(:)))

imshow(squeeze(abs(kspace(1,1,1,:,:,200))),[])


end